{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pgcrud","text":"<p>pgcrud is a Python package that makes Create, Read, Update, and Delete (CRUD) operations for PostgreSQL simple and fast. </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>No ORM, only declarative expressions.</li> <li>Built-in pydantic and msgspec support for data serialization &amp; validation</li> <li>Efficient handling of complex parent-child relationships </li> <li>Perform operations sync or async.</li> <li>Full type hint support.</li> <li>Easy to integrate into existing projects.</li> <li>Protection against SQL-Injection</li> <li>Tailored to PostgreSQL with wide extensions support.</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>pgcrud's only dependency is psycopg including it's binary and pool extensions.</p>"},{"location":"#optional","title":"Optional","text":"<p>For data serialization &amp; validation you can choose between:</p> <ul> <li>pydantic: the most popular library.</li> <li>msgspec: the fastest library.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>pgcrud is not yet available on PyPI. However, you can install it using pip with the following command:</p> <pre><code>pip install git+https://github.com/dakivara/pgcrud.git\n</code></pre> <p>To use pydantic or msgspec, ensure you install them separately, as they are optional dependencies.</p> <p>Do not download the pgcrud package from PyPi. This is an abandoned package and is not affiliated with us.</p>"},{"location":"#cursor","title":"Cursor","text":"<p>pgcrud extends the psycopg cursor by directly fetching and validating the data with your preferred data serialization &amp; validation library.</p> syncasync <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nwith pg.connect('CONN_STR') as conn:\n    with conn.cursor() as cursor:\n        cursor[Author].execute(\"SELECT 1 AS id, 'J.K. Rowling' AS name\").fetchone()\n        # returns Author(id=1, name='J.K. Rowling')\n\n        cursor[str].execute(\"SELECT 1\").fetchone()\n        # raises ValidationError: Input should be a valid string [type=string_type, input_value=1, input_type=int]\n</code></pre> <pre><code>import asyncio    \n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nasync def main():\n    async with await pg.async_connect('CONN_STR') as conn:\n        async with conn.cursor() as cursor:\n            await cursor[Author].execute(\"SELECT 1 AS id, 'J.K. Rowling' AS name\")\n            await cursor.fetchone()\n            # returns Author(id=1, name='J.K. Rowling')\n\n            await cursor[str].execute(\"SELECT 1\")\n            await cursor.fetchone()\n            # raises ValidationError: Input should be a valid string [type=string_type, input_value=1, input_type=int]\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"#crud-examples","title":"CRUD Examples","text":"<p>This is a high level overview of the pgcrud operations. For more detailed instructions and advanced examples, be sure to  explore the rest of the documentation. </p> <p>In the following examples, we use a simple Author model based on an author table with  the columns id, name, and date_of_birth.</p>"},{"location":"#create","title":"Create","text":"<p>The <code>insert_one</code> / <code>insert_many</code> methods are used to insert one / many records into a table. You must specify into which table  you want to insert and which columns you want to populate. You can simply insert new records from Pydantic objects. Typically, the id column is autogenerated and you can retrieve it after insertion.</p> syncasync <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n\n\ndef insert_author(\n        cursor: pg.Cursor,\n        input_: AuthorInput,\n) -&gt; int | None:\n\n    return pg.insert_one(\n        cursor=cursor[int],\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n        returning=i.id,\n    )\n</code></pre> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n\n\nasync def insert_author(\n        cursor: pg.AsyncCursor,\n        input_: AuthorInput,\n) -&gt; int | None:\n\n    return await pg.async_insert_one(\n        cursor=cursor[int],\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n        returning=i.id,\n    )\n</code></pre>"},{"location":"#read","title":"Read","text":"<p>The <code>get_one</code> / <code>get_many</code> methods are used to retrieve one / many records from a table. You must specify from with table you want to select the records. You can directly load the fetched records into a Pydantic model. The <code>where</code> condition specifies which records should be retrieved.  If the where condition matches multiple records, the <code>get_one</code> method will return the first record that meets the filter criteria.</p> syncasync <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n    date_of_birth: date\n\n\ndef get_author(\n        cursor: pg.Cursor,\n        id_: int,\n) -&gt; Author | None:\n\n    return pg.get_one(\n        cursor=cursor[Author],\n        select=(i.id, i.name, i.date_of_birth),\n        from_=i.author,\n        where=i.id == id_,\n    )\n</code></pre> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n    date_of_birth: date\n\n\nasync def get_author(\n        cursor: pg.AsyncCursor,\n        id_: int,\n) -&gt; Author | None:\n\n    return await pg.async_get_one(\n        cursor=cursor[Author],\n        select=(i.id, i.name, i.date_of_birth),\n        from_=i.author,\n        where=i.id == id_,\n    )\n</code></pre>"},{"location":"#update","title":"Update","text":"<p>The <code>update_many</code> method is used to update records in a table.<sup>1</sup> You need to specify which table and which columns you want to update.  The <code>where</code> condition specifies which records should be updated. To update a single record, you must ensure that the <code>where</code> condition  targets a single record. </p> syncasync <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorUpdate(BaseModel):\n    name: str\n    date_of_birth: date\n\n\ndef update_author(\n        cursor: pg.Cursor, \n        update: AuthorUpdate, \n        id_: int,\n) -&gt; None:\n\n    pg.update_many(\n        cursor=cursor,\n        update=i.author,\n        set_=((i.name, i.date_of_birth), update),\n        where=i.id == id_,\n    )\n</code></pre> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorUpdate(BaseModel):\n    name: str\n    date_of_birth: date\n\n\nasync def update_author(\n        cursor: pg.AsyncCursor, \n        update: AuthorUpdate,\n        id_: int,\n) -&gt; None:\n\n    await pg.async_update_many(\n        cursor=cursor,\n        update=i.author,\n        set_=((i.name, i.date_of_birth), update),\n        where=i.id == id_,\n    )\n</code></pre>"},{"location":"#delete","title":"Delete","text":"<p>The <code>delete_many</code> method is used to delete records from a table.<sup>2</sup> You need to specify from which table you want to delete the records.  The <code>where</code> condition specifies which records should be deleted. To delete a single record, you must ensure that the <code>where</code> condition  targets a single record. </p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef delete_author(\n        cursor: pg.Cursor, \n        id_: int,\n) -&gt; None:\n\n    pg.delete_many(\n        cursor=cursor,\n        delete_from=i.author,\n        where=i.id == id_,\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def delete_author(\n        cursor: pg.AsyncCursor, \n        id_: int,\n) -&gt; None:\n\n    await pg.async_delete_many(\n        cursor=cursor,\n        delete_from=i.author,\n        where=i.id == id_,\n    )\n</code></pre>"},{"location":"#license","title":"License","text":"<p>pgcrud is released under the MIT License.</p> <ol> <li> <p>An <code>update_one</code> method does not exist because PostgreSQL's UPDATE command does not inherently target a single record.\u00a0\u21a9</p> </li> <li> <p>A <code>delete_one</code> method does not exist because PostgreSQL's DELETE command does not inherently target a single record.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":"<p>pgcrud is designed to closely mirror PostgreSQL's query language. If you are familiar  with PostgreSQL, you will quickly recognize the similarities, making this tutorial much easier to follow.</p> <p>There are 3 components in pgcrud which are essential for unlocking its full functionality.</p> <ul> <li>Expressions: Represent database objects.</li> <li>Functions: Facilitates the use of PostgreSQL functions.</li> <li>Query Builder: Enables modular query construction, mirroring PostgreSQL.</li> </ul>"},{"location":"getting-started/#expressions","title":"Expressions","text":"<p>Expressions represents database objects such as columns, tables, or  values like integers, text, booleans, and similar types.</p>"},{"location":"getting-started/#identifiers","title":"Identifiers","text":"<p>An identifier represents a database object, such as a column, table, or other entity. Any  attribute of the identifier class is an identifier and any attribute of an identifier is  again an identifier<sup>1</sup>. </p> <pre><code>from pgcrud import IdentifierExpression as i\n\ni.author\n# \"author\"\n\ni.name\n# \"name\"\n\ni.author.name\n# \"author\".\"name\"\n</code></pre>"},{"location":"getting-started/#literals","title":"Literals","text":"<p>The Literal class is used to convert Python built-in types into PostgreSQL data types..</p> <pre><code>from datetime import datetime\n\nfrom pgcrud import LiteralExpression as l\n\nl(1)\n# 1\n\nl(datetime.now())\n# '2025-01-12 15:59:10.179785'::timestamp\n\nl([1, 2, 3])\n# '{1,2,3}'::int2[]\n</code></pre>"},{"location":"getting-started/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>Expressions fully support arithmetic operations with each other and with built-in Python objects. <sup>2</sup> </p> <pre><code>from pgcrud import IdentifierExpression as i\n\ni.salary + i.bonus\n# \"salary\" + \"bonus\"\n\ni.net_price * 1.2\n# \"net_price\" * 1.2\n\ni.weight / i.height ** 2\n# \"weight\" / (\"height\" ^ 2)\n</code></pre>"},{"location":"getting-started/#comparison-operations","title":"Comparison Operations","text":"<p>Expressions fully support comparison operations with each other and with built-in Python objects. Additionally, you can  chain them logically using the <code>&amp;</code> and <code>|</code> operators.</p> <pre><code>from pgcrud import IdentifierExpression as i\n\ni.author.id == 1\n# \"author\".\"id\" = 1\n\ni.salary + i.bonus &gt; 10000\n# \"salary\" + \"bonus\" &gt; 10000\n\ni.id.IN(1, 2, 3)\n# \"id\" IN (1, 2, 3)\n\n(i.age &gt; 4) | (i.height &gt; 100)\n# \"age\" &gt; 4 OR \"height\" &gt; 100\n</code></pre>"},{"location":"getting-started/#sort-operations","title":"Sort Operations","text":"<p>Each expression can specify the ordering of data in either ascending or descending order, with the option to reverse the order using a boolean flag.</p> <pre><code>from pgcrud import IdentifierExpression as i\n\ni.id.ASC()\n# \"id\" ASC\n\ni.name.DESC()\n# \"name\" DESC\n\ni.id.ASC(False)\n# \"id\" DESC\n\ni.name.DESC(False)\n# \"name\" ASC\n</code></pre>"},{"location":"getting-started/#table-identifier","title":"Table identifier","text":"<p>For insert operations, you need to specify the target table and the columns you want to populate.</p> <pre><code>from pgcrud import IdentifierExpression as i\n\ni.author[i.name, i.date_of_birth]\n# \"author\" (\"name\", \"date_of_birth\")\n</code></pre>"},{"location":"getting-started/#aliases","title":"Aliases","text":"<p>You can alias any expression to simplify or make your code clearer.</p> <pre><code>from pgcrud import IdentifierExpression as i\n\n(i.salary + i.bonus).AS(i.total_compensation)\n# \"salary\" + \"bonus\" AS \"total_compensation\"\n\n(i.weight / i.height ** 2).AS(i.bmi)\n# \"weight\" / (\"height\" ^ 2) AS \"bmi\"\n</code></pre>"},{"location":"getting-started/#join-expressions","title":"Join Expressions","text":"<p>Expressions support defining joins in a style similar to PostgreSQL. </p> <pre><code>from pgcrud import IdentifierExpression as i\n\ni.book \\\n    .LEFT_JOIN(i.autor) \\\n    .ON(i.book.author_id == i.author.id)\n# \"book\" LEFT JOIN \"autor\" ON \"book\".\"author_id\" = \"author\".\"id\"\n\ni.employee.AS(i.e) \\\n    .JOIN(i.department.AS(i.d)) \\\n    .ON((i.e.department_id == i.d.id) &amp; (i.d.type == 'Finance'))\n# \"employee\" AS \"e\" JOIN \"department\" AS \"d\" ON \"e\".\"department_id\" = \"d\".\"id\" AND \"d\".\"type\" = 'Finance'\n</code></pre>"},{"location":"getting-started/#undefined-type","title":"Undefined Type","text":"<p>pgcrud includes a special object called <code>pg.UNDEFINED</code>. When used in comparison or sorting operations, it is automatically ignored. This  feature is particularly useful for handling optional parameters.</p> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n(i.id == 1) &amp; (i.name == pg.UNDEFINED)\n# \"id\" = 1\n\ni.id.ASC(pg.UNDEFINED)\n#\n</code></pre>"},{"location":"getting-started/#functions","title":"Functions","text":"<p>The Function Bearer encapsulates all PostgreSQL functions, which can be used to transform or aggregate database objects.</p> <pre><code>from pgcrud import functions as f, IdentifierExpression as i\n\nf.avg(i.salary)\n# avg(\"salary\")\n\nf.coalesce(i.score, 0)\n# coalesce(\"score\", 0)\n\nf.json_agg(i.book)\n# json_agg(\"book\")\n</code></pre>"},{"location":"getting-started/#query-builder","title":"Query Builder","text":"<p>The Query Builder is used to chain multiple clauses together to construct an SQL query. You typically use this to  define windows, subqueries or to construct queries that cannot be achieved using the pre-defined CRUD operations provided by pgcrud.</p>"},{"location":"getting-started/#window","title":"Window","text":"<p>You can define windows or use the <code>OVER</code> clause.</p> <pre><code>import pgcrud as pg\nfrom pgcrud import functions as f, IdentifierExpression as i, QueryBuilder as q\n\ni.w.AS(\n    q.PARTITION_BY(i.product_id).\n    ORDER_BY(i.sale_timestamp).\n    ROWS_BETWEEN(pg.UNBOUNDED.PRECEDING, pg.CURRENT_ROW)\n)\n# \"w\" AS (PARTITION BY \"product_id\" ORDER BY \"sale_timestamp\" ROWS BETWEEN UNBOUNDED PRECEDING CURRENT ROW)\n\n(i.salary / f.avg(i.salary)).OVER(q.PARTITION_BY(i.department_id)).AS(i.relative_salary)\n# \"salary\" / avg(\"salary\") OVER (PARTITION BY \"department_id\") AS \"relative_salary\"\n</code></pre>"},{"location":"getting-started/#subquery","title":"Subquery","text":"<p>You can use subqueries in filter expressions or join expressions.</p> <pre><code>from pgcrud import functions as f, IdentifierExpression as i, QueryBuilder as q\n\ni.id.IN(\n    q.SELECT(i.department_id).\n    FROM(i.employee).\n    GROUP_BY(i.department_id).\n    HAVING(f.avg(i.salary) &gt; 10000)\n)\n# \"id\" IN ((SELECT \"department_id\" FROM \"employee\" GROUP BY \"department_id\" HAVING avg(\"salary\") &gt; 10000))\n\ni.author.JOIN(\n    q.SELECT(i.author_id, f.json_agg(i.book).AS(i.books)).\n        FROM(i.book).\n        GROUP_BY(i.author_id).\n        AS(i.author_books)\n    ).ON(i.author.id == i.author_books.author_id)\n# \"author\" JOIN (SELECT \"author_id\", json_agg(\"book\") AS \"books\" FROM \"book\" GROUP BY \"author_id\") AS \"author_books\" ON \"author\".\"id\" = \"author_books\".\"author_id\"\n</code></pre>"},{"location":"getting-started/#common-table-expression-cte","title":"Common Table Expression (CTE)","text":"<p>pgcrud provides pre-defined functions for most relevant CRUD operations but does not cover cases like CTEs. In  such scenarios, you can use the Query Builder to construct your query.</p> <pre><code>from pgcrud import functions as f, IdentifierExpression as i, QueryBuilder as q\n\nq.WITH(\n    i.stats.AS(\n        q.SELECT(i.department_id, f.avg(i.salary).AS(i.avg_salary)).\n        FROM(i.employee).\n        GROUP_BY(i.department_id)\n    )\n).INSERT_INTO(i.department_stats[i.id, i.avg_salary]) \\\n    .SELECT(i.department_id, i.avg_salary) \\\n    .FROM(i.stats)\n# WITH \"stats\" AS (SELECT \"department_id\", avg(\"salary\") AS \"avg_salary\" FROM \"employee\" GROUP BY \"department_id\") INSERT INTO \"department_stats\" (\"id\", \"avg_salary\") SELECT \"department_id\", \"avg_salary\" FROM \"stats\"\n</code></pre> <ol> <li> <p>Except for keywords, like <code>JOIN</code>, <code>OVER</code> or <code>AS</code>, which a pre-defined methods of an expression.\u00a0\u21a9</p> </li> <li> <p>Built in types are automatically converted to literals.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/create/","title":"Create","text":"<p> Note: Make sure to read the Getting Started, Demo Schema and Cursor first, as it is essential for better understanding of this tutorial. </p> <p>pgcrud has two functions to perform synchronous insert operations:</p> <ul> <li><code>pg.insert_one</code>: Insert a single record and optionally return the inserted record.</li> <li><code>pg.insert_many</code>: Insert multiple records and optionally return the inserted records or an iterable cursor.</li> </ul> <p>And pgcrud has two function to perform asynchronous insert operations:</p> <ul> <li><code>pg.async_insert_one</code>: Analogous to <code>pg.insert_one</code>.</li> <li><code>pg.async_insert_many</code>: Analogous to <code>pg.insert_many</code>.</li> </ul>"},{"location":"getting-started/create/#parameters","title":"Parameters","text":"<p>The following parameters are available:</p> <ul> <li><code>cursor</code> (required): To execute the query.</li> <li><code>insert_into</code> (required): To specify in which table to insert and which columns to populate.</li> <li><code>values</code> (required): The values to insert.</li> <li><code>on_conflict</code> (optional): To handle conflicts.</li> <li><code>returning</code> (optional): To return the inserted records.</li> <li><code>additional_values</code> (optional): Additional values that can be inserted.</li> <li><code>no_fetch</code> (optional): To execute only.<sup>1</sup></li> </ul>"},{"location":"getting-started/create/#cursor","title":"Cursor","text":"<p>The <code>cursor</code> parameter is explained in detail here.</p>"},{"location":"getting-started/create/#insert-into","title":"Insert Into","text":"<p>The <code>insert_into</code> specifies into which table you want to insert and which columns you want to populate. You need to pass  an identifier or table identifier to this parameter.</p> syncasync <pre><code>from datetime import date\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef insert_author(\n        cursor: pg.Cursor,\n        name: str,\n        date_of_birth: date,\n) -&gt; None:\n\n    pg.insert_one(\n        cursor=cursor,\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=(name, date_of_birth),\n    )\n</code></pre> <pre><code>from datetime import date\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def insert_author(\n        cursor: pg.AsyncCursor,\n        name: str,\n        date_of_birth: date,\n) -&gt; None:\n\n    await pg.async_insert_one(\n        cursor=cursor,\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=(name, date_of_birth),\n    )\n</code></pre>"},{"location":"getting-started/create/#values","title":"Values","text":"<p>The <code>values</code> parameter specifies the records to be inserted into the table. As the names suggest, the <code>insert_one</code> method  inserts a single record and <code>insert_many</code> inserts many records.</p>"},{"location":"getting-started/create/#single-record","title":"Single Record","text":"<p>In the <code>insert_one</code> method, the <code>values</code> parameter typically expects a tuple, dictionary or model instance.</p> syncasync <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n\n\ndef insert_author(\n        cursor: pg.Cursor,\n        input_: AuthorInput,\n) -&gt; None:\n\n    pg.insert_one(\n        cursor=cursor,\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n    )\n</code></pre> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n\n\nasync def insert_author(\n        cursor: pg.AsyncCursor,\n        input_: AuthorInput,\n) -&gt; None:\n\n    await pg.async_insert_one(\n        cursor=cursor,\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n    )\n</code></pre>"},{"location":"getting-started/create/#multiple-records","title":"Multiple Records","text":"<p>In the <code>insert_many</code> method, the <code>values</code> parameter expects a sequence of tuples, dictionaries or model instance.</p> syncasync <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n\n\ndef insert_authors(\n        cursor: pg.Cursor,\n        input_: list[AuthorInput],\n) -&gt; None:\n\n    pg.insert_many(\n        cursor=cursor,\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n    )\n</code></pre> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n\n\nasync def insert_authors(\n        cursor: pg.AsyncCursor,\n        input_: list[AuthorInput],\n) -&gt; None:\n\n    await pg.async_insert_many(\n        cursor=cursor,\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n    )\n</code></pre>"},{"location":"getting-started/create/#on-conflict","title":"On Conflict","text":"<p>The <code>on_conflict</code> parameter is used to manage conflicts that arise from constraint violations and  requires a query as its input.</p> syncasync <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, QueryBuilder as q\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n\n\ndef insert_author(\n        cursor: pg.Cursor,\n        input_: AuthorInput,\n) -&gt; None:\n\n    pg.insert_one(\n        cursor=cursor,\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n        on_conflict=q.ON_CONSTRAINT(i.author_name_key).DO_NOTHING,\n    )\n</code></pre> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, QueryBuilder as q\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n\n\nasync def insert_author(\n        cursor: pg.AsyncCursor,\n        input_: AuthorInput,\n) -&gt; None:\n\n    await pg.async_insert_one(\n        cursor=cursor,\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n        on_conflict=q.ON_CONSTRAINT(i.author_name_key).DO_NOTHING,\n    )\n</code></pre>"},{"location":"getting-started/create/#returning","title":"Returning","text":"<p>The <code>returning</code> parameter is used to retrieve the record after insertion<sup>2</sup>. The <code>returning</code> parameter  expects a single or multiple expressions as input.</p> syncasync <pre><code>from datetime import date\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef insert_book(\n        cursor: pg.Cursor,\n        input_: tuple[str, date, int],        \n) -&gt; int:\n\n    return pg.insert_one(\n        cursor=cursor[int],\n        insert_into=i.book[i.title, i.publication_date, i.author_id],\n        values=input_,\n        returning=i.id,\n    )\n</code></pre> <pre><code>from datetime import date\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def insert_book(\n        cursor: pg.AsyncCursor,\n        input_: tuple[str, date, int],        \n) -&gt; int:\n\n    return await pg.async_insert_one(\n        cursor=cursor[int],\n        insert_into=i.book[i.title, i.publication_date, i.author_id],\n        values=input_,\n        returning=i.id,\n    )\n</code></pre>"},{"location":"getting-started/create/#additional-values","title":"Additional Values","text":"<p>The <code>additonal_values</code> parameter is especially useful when the model instance being inserted does not contain all the required  data. A common example is foreign keys, which may not be part of the model instance but still need to be included in the  insertion. The <code>additional_values</code> expects a dictionary as input.</p> syncasync <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass BookInput(BaseModel):\n    title: str\n    publication_date: date\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n    books: list[BookInput]\n\n\ndef insert_author_with_books(\n        cursor: pg.Cursor,\n        input_: AuthorInput,\n) -&gt; None:\n\n    author_id = pg.insert_one(\n        cursor[int],\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n        returning=i.id,\n    )\n\n    pg.insert_many(\n        cursor=cursor,\n        insert_into=i.book[i.title, i.publication_date, i.author_id],\n        values=input_.books,\n        additional_values={'author_id': author_id},\n    ) \n</code></pre> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass BookInput(BaseModel):\n    title: str\n    publication_date: date\n\n\nclass AuthorInput(BaseModel):\n    name: str\n    date_of_birth: date\n    books: list[BookInput]\n\n\nasync def insert_author_with_books(\n        cursor: pg.AsyncCursor,\n        input_: AuthorInput,\n) -&gt; None:\n\n    author_id = await pg.async_insert_one(\n        cursor[int],\n        insert_into=i.author[i.name, i.date_of_birth],\n        values=input_,\n        returning=i.id,\n    )\n\n    await pg.async_insert_many(\n        cursor=cursor,\n        insert_into=i.book[i.title, i.publication_date, i.author_id],\n        values=input_.books,\n        additional_values={'author_id': author_id},\n    ) \n</code></pre>"},{"location":"getting-started/create/#no-fetch","title":"No Fetch","text":"<p>The <code>no_fetch</code> parameter determines whether to fetch the data or only execute the query. It is only available in the <code>insert_many</code> methods. By default, it is set to <code>False</code>. If set to <code>True</code>, the method will return a cursor, making it more time and memory efficient  when you need to iterate through the data without loading it all at once.</p> syncasync <pre><code>from datetime import date\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef insert_books(\n        cursor: pg.Cursor,\n        input_: list[tuple[str, date, int]],        \n) -&gt; pg.Cursor[int]:\n\n    return pg.insert_many(\n        cursor=cursor[int],\n        insert_into=i.book[i.title, i.publication_date, i.author_id],\n        values=input_,\n        returning=i.id,\n        no_fetch=True,\n    )\n</code></pre> <pre><code>from datetime import date\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def insert_books(\n        cursor: pg.AsyncCursor,\n        input_: list[tuple[str, date, int]],        \n) -&gt; pg.AsyncCursor[int]:\n\n    return await pg.async_insert_many(\n        cursor=cursor[int],\n        insert_into=i.book[i.title, i.publication_date, i.author_id],\n        values=input_,\n        returning=i.id,\n        no_fetch=True,\n    )\n</code></pre> <ol> <li> <p>Only available in <code>pg.insert_many</code> and <code>pg.async_insert_many</code>.\u00a0\u21a9</p> </li> <li> <p>Typically you want to retrieve the autogenerated id.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/cursor/","title":"Cursor","text":"<p>The pgcrud cursor extends the psycopg cursor, offering enhanced functionality and usability:</p> <ul> <li>Row Factory Integration: Supports passing a row factory directly via type hints.</li> <li>Built-in Serialization &amp; Validation: Provides integration with your preferred data serialization and validation library.</li> <li>Execute Queries for Query Builder: You can directly execute your queries from the pgcrud Query Builder.</li> </ul>"},{"location":"getting-started/cursor/#row-factory","title":"Row Factory","text":"<p>You can use a type hint square brackets on a cursor and pgcrud will choose the appropriate row factory.</p> syncasync <pre><code>import pgcrud as pg\n\n\nwith pg.connect('CONN_STR') as conn:\n    with conn.cursor() as cursor:\n        cursor[int].execute(\"SELECT 1\").fetchone()\n        # returns 1\n\n        cursor[tuple].execute(\"SELECT 1, 'J.K. Rowling'\").fetchone()\n        # returns (1, 'J.K. Rowling')\n\n        cursor[list].execute(\"SELECT 1, 'J.K. Rowling'\").fetchone()\n        # returns [1, 'J.K. Rowling']\n\n        cursor[dict].execute(\"SELECT 1 AS id, 'J.K. Rowling' AS name\").fetchone()\n        # returns {'id': 1, 'name': 'J.K. Rowling'}\n</code></pre> <pre><code>import asyncio    \n\nimport pgcrud as pg\n\n\nasync def main():\n    async with await pg.async_connect('CONN_STR') as conn:\n        async with conn.cursor() as cursor:\n            await cursor[int].execute(\"SELECT 1\")\n            await cursor.fetchone()\n            # returns 1\n\n            await cursor[tuple].execute(\"SELECT 1, 'J.K. Rowling'\")\n            await cursor.fetchone()\n            # returns (1, 'J.K. Rowling')\n\n            await cursor[list].execute(\"SELECT 1, 'J.K. Rowling'\")\n            await cursor.fetchone()\n            # returns [1, 'J.K. Rowling']\n\n            await cursor[dict].execute(\"SELECT 1 AS id, 'J.K. Rowling' AS name\")\n            await cursor.fetchone()\n            # returns {'id': 1, 'name': 'J.K. Rowling'}\n\n\nasyncio.run(main())\n</code></pre> <p>You can provide more detailed type hints, but pgcrud does not perform additional data validation.<sup>1</sup> Since the database already  enforces type safety, it is often unnecessary to revalidate types in Python, especially when performance is critical.</p> syncasync <pre><code>from typing import TypedDict\n\nimport pgcrud as pg\n\n\nclass Author(TypedDict):\n    id: int\n    name: str\n\n\nwith pg.connect('CONN_STR') as conn:\n    with conn.cursor() as cursor:\n        cursor[tuple[int, str]].execute(\"SELECT 1, 'J.K. Rowling'\").fetchone()\n        # returns (1, 'J.K. Rowling')\n\n        cursor[Author].execute(\"SELECT 1 AS id, 'J.K. Rowling' AS name\").fetchone()\n        # returns {'id': 1, 'name': 'J.K. Rowling'}\n</code></pre> <pre><code>import asyncio \nfrom typing import TypedDict\n\nimport pgcrud as pg\n\n\nclass Author(TypedDict):\n    id: int\n    name: str\n\n\nasync def main():\n    async with await pg.async_connect('CONN_STR') as conn:\n        async with conn.cursor() as cursor:\n            await cursor[tuple[int, str]].execute(\"SELECT 1, 'J.K. Rowling'\")\n            await cursor.fetchone()\n            # returns (1, 'J.K. Rowling')\n\n            await cursor[Author].execute(\"SELECT 1 AS id, 'J.K. Rowling' AS name\")\n            await cursor.fetchone()\n            # returns {'id': 1, 'name': 'J.K. Rowling'}\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/cursor/#serialization-validation","title":"Serialization &amp; Validation","text":"<p>pgcrud currently supports the following data serialization &amp; validation libraries:</p> <ul> <li>pydantic: the most popular library.</li> <li>msgspec: the fastest library.</li> </ul> <p>If one of the two libraries is installed, pgcrud will automatically use it for validation.<sup>2</sup> You can use model instances both to  determine the row factory and as input parameters.</p> syncasync <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nwith pg.connect('CONN_STR') as conn:\n    with conn.cursor() as cursor:\n        cursor[tuple[int, str]].execute(\n            query=\"SELECT %(id)s, %(name)s\", \n            params=Author(id=1, name='J.K. Rowling'),\n        ).fetchone()\n        # returns (1, 'J.K. Rowling')\n\n        cursor[Author].execute(\"SELECT 1 AS id, 'J.K. Rowling' AS name\").fetchone()\n        # returns Author(id=1 name='J.K. Rowling')\n\n        cursor[str].execute(\"SELECT 1\").fetchone()\n        # raises ValidationError: Input should be a valid string [type=string_type, input_value=1, input_type=int]\n</code></pre> <pre><code>import asyncio \n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nasync def main():\n    async with await pg.async_connect('CONN_STR') as conn:\n        async with conn.cursor() as cursor:\n            await cursor[tuple[int, str]].execute(\n                query=\"SELECT %(id)s, %(name)s\", \n                params=Author(id=1, name='J.K. Rowling'),\n            )\n            await cursor.fetchone()\n            # returns (1, 'J.K. Rowling')\n\n            await cursor[Author].execute(\"SELECT 1 AS id, 'J.K. Rowling' AS name\")\n            await cursor.fetchone()\n            # returns Author(id=1 name='J.K. Rowling')\n\n            await cursor[str].execute(\"SELECT 1\")\n            await cursor.fetchone()\n            # raises ValidationError: Input should be a valid string [type=string_type, input_value=1, input_type=int]\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/cursor/#queries-from-query-builder","title":"Queries from Query Builder","text":"<p>You can pass a Query from the Query Builder just like a normal SQL query.</p> syncasync <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, QueryBuilder as q\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nwith pg.connect('CONN_STR') as conn:\n    with conn.cursor() as cursor:\n        cursor[Author].execute(\n            query=q.SELECT(\n                pg.Placeholder().AS(i.id), \n                pg.Placeholder().AS(i.name),\n            ), \n            params=(1, 'J.K. Rowling'),\n        ).fetchone()\n        # returns Author(id=1 name='J.K. Rowling')\n\n        cursor[tuple[int, str]].execute(\n            query=q.SELECT(\n                pg.Placeholder('id'), \n                pg.Placeholder('name'),\n            ), \n            params=Author(id=1, name='J.K. Rowling'),\n        ).fetchone()\n        # returns (1, 'J.K. Rowling')\n</code></pre> <pre><code>import asyncio\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, QueryBuilder as q\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nasync def main():\n    async with await pg.async_connect('CONN_STR') as conn:\n        async with conn.cursor() as cursor:\n            await cursor[Author].execute(\n                query=q.SELECT(\n                    pg.Placeholder().AS(i.id), \n                    pg.Placeholder().AS(i.name),\n                ), \n                params=(1, 'J.K. Rowling'),\n            )\n            await cursor.fetchone()\n            # returns Author(id=1 name='J.K. Rowling')\n\n            await cursor[tuple[int, str]].execute(\n                query=q.SELECT(\n                    pg.Placeholder('id'), \n                    pg.Placeholder('name'),\n                ), \n                params=Author(id=1, name='J.K. Rowling'),\n            )\n            await cursor.fetchone()\n            # returns (1, 'J.K. Rowling')\n\nasyncio.run(main())\n</code></pre> <ol> <li> <p>Unless you have one of the supported validation libraries installed.\u00a0\u21a9</p> </li> <li> <p>If both libraries are installed, pgcrud will use pydantic by default. You can change it by changing the value of <code>pg.config.validation</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/delete/","title":"Delete","text":"<p> Note: Make sure to read the Getting Started, Demo Schema and Cursor first, as it is essential for better understanding of this tutorial. </p>"},{"location":"getting-started/demo-schema/","title":"Demo Schema","text":"<p>We have set up a demo schema that will be used throughout this tutorial. Be sure to set up the  demo schema in order to run the code examples with the provided sample data. You can find the  demo schema here. The demo schema consists of two tables: </p> <ul> <li>author:</li> </ul> <pre><code>CREATE TABLE author (\n    id serial PRIMARY KEY,\n    name varchar(255) NOT NULL,\n    date_of_birth date NOT NULL\n)\n</code></pre> <ul> <li>book:</li> </ul> <pre><code>CREATE TABLE book (\n    id serial PRIMARY KEY,\n    title varchar(255) NOT NULL,\n    publication_date date NOT NULL,\n    author_id int NOT NULL,\n    FOREIGN KEY (author_id) REFERENCES author(id)\n)\n</code></pre> <p>The schema illustrates a straightforward one-to-many relationship, where the author  serves as the parent and the books as the children. The script also includes insert  statements with sample data featuring some of my favorite authors and books.</p>"},{"location":"getting-started/read/","title":"Read","text":"<p> Note: Make sure to read the Getting Started, Demo Schema and Cursor first, as it is essential for better understanding of this tutorial. </p> <p>pgcrud has two functions to perform synchronous read operations:</p> <ul> <li><code>pg.get_one</code>: Retrieve a single record. If no record is found, the method returns <code>None</code>. If more than one record is found, the method returns the first one.</li> <li><code>pg.get_many</code>: Retrieve either a list of records or an iterable cursor.</li> </ul> <p>And pgcrud has two function to perform asynchronous read operations:</p> <ul> <li><code>pg.async_get_one</code>: Analogous to <code>pg.get_one</code>.</li> <li><code>pg.async_get_many</code>: Analogous to <code>pg.get_many</code>.</li> </ul>"},{"location":"getting-started/read/#parameters","title":"Parameters","text":"<p>The following parameters are available:</p> <ul> <li><code>cursor</code> (required): To execute the query.</li> <li><code>select</code> (required): To specify the selected columns.</li> <li><code>from_</code> (required): To define the target.<sup>1</sup></li> <li><code>where</code> (optional): To filter records.</li> <li><code>group_by</code> (optional): To group by columns.</li> <li><code>having</code> (optional): To filter by aggregated columns.</li> <li><code>window</code> (optional): To define windows.</li> <li><code>order_by</code> (optional): To sort by columns.</li> <li><code>limit</code> (optional): To limit the number of records.<sup>2</sup></li> <li><code>offset</code> (optional): To skip the first n records.</li> <li><code>no_fetch</code> (optional): To execute only.<sup>2</sup></li> </ul>"},{"location":"getting-started/read/#cursor","title":"Cursor","text":"<p>The <code>cursor</code> parameter is explained in detail here.</p>"},{"location":"getting-started/read/#select","title":"Select","text":"<p>You can use a single expression to select a single column or a sequence of expressions to select multiple columns. <sup>3</sup></p>"},{"location":"getting-started/read/#single-column","title":"Single Column","text":"<p>You use a single expression to select a specific column from a table, accompanied by an appropriate scalar type hint for the cursor.</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef get_author_name(\n        cursor: pg.Cursor, \n        id_: int,\n) -&gt; str | None:\n\n    return pg.get_one(\n        cursor=cursor[str],\n        select=i.name,\n        from_=i.author,\n        where=i.id == id_,\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def get_author_name(\n        cursor: pg.AsyncCursor, \n        id_: int,\n) -&gt; str | None:\n\n    return await pg.async_get_one(\n        cursor=cursor[str],\n        select=i.name,\n        from_=i.author,\n        where=i.id == id_,\n    )\n</code></pre>"},{"location":"getting-started/read/#multiple-columns","title":"Multiple Columns","text":"<p>You use a sequence of expressions to select multiple columns from a table, with the option to fetch the results as a tuple, dictionary, or model instance.</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef get_book_ids_and_titles(\n        cursor: pg.Cursor, \n        author_id: int,\n) -&gt; tuple[int, str] | None:\n\n    return pg.get_many(\n        cursor=cursor[tuple[int, str]],\n        select=(i.id, i.title),\n        from_=i.book,\n        where=i.author_id == author_id,\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def get_book_ids_and_titles(\n        cursor: pg.AsyncCursor, \n        author_id: int,\n) -&gt; tuple[int, str] | None:\n\n    return await pg.async_get_many(\n        cursor=cursor[tuple[int, str]],\n        select=(i.id, i.title),\n        from_=i.book,\n        where=i.author_id == author_id,\n    )\n</code></pre>"},{"location":"getting-started/read/#from","title":"From","text":"<p>The <code>from_</code> specifies the target. The target is typically a table (or view), joined table, or subquery.</p>"},{"location":"getting-started/read/#table-or-view","title":"Table (or View)","text":"<p>You use an expression to select from table (or view).</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef get_book_ids(cursor: pg.Cursor) -&gt; list[int]:\n    return pg.get_many(\n        cursor=cursor[int],\n        select=i.id,\n        from_=i.book,\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def get_book_ids(cursor: pg.AsyncCursor) -&gt; list[int]:\n    return await pg.async_get_many(\n        cursor=cursor[int],\n        select=i.id,\n        from_=i.book,\n    )\n</code></pre>"},{"location":"getting-started/read/#joined-table","title":"Joined Table","text":"<p>You use a joined expression to select from a joined table. In such a case you will typically load fetched data into data models.</p> syncasync <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, functions as f\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: Author\n\n\ndef get_book(\n        cursor: pg.Cursor,\n        id_: int,\n) -&gt; Book | None:\n\n    return pg.get_one(\n        cursor=cursor[Book],\n        select=(i.book.id, i.book.title, f.to_json(i.author).AS(i.author)),\n        from_=i.book.\n            JOIN(i.author).ON(i.book.author_id == i.author.id),\n        where=i.book.id == id_,\n    )\n</code></pre> <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, functions as f\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: Author\n\n\nasync def get_book(\n        cursor: pg.AsyncCursor,\n        id_: int,\n) -&gt; Book | None:\n\n    return await pg.async_get_one(\n        cursor=cursor[Book],\n        select=(i.book.id, i.book.title, f.to_json(i.author).AS(i.author)),\n        from_=i.book.\n            JOIN(i.author).ON(i.book.author_id == i.author.id),\n        where=i.book.id == id_,\n    )\n</code></pre>"},{"location":"getting-started/read/#where","title":"Where","text":"<p>The <code>where</code> parameter is used to specify conditions for filtering records to fetch. It  accepts a comparison expression as its input. This can be a single comparison expression or an  intersection or union of expressions. </p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef get_book_titles(\n        cursor: pg.Cursor,\n        author_id_1: int,\n        author_id_2: int,\n) -&gt; list[str]:\n\n    return pg.get_many(\n        cursor=cursor[str],\n        select=i.title,\n        from_=i.book,\n        where=(i.author_id == author_id_1) | (i.author_id == author_id_2),\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def get_book_titles(\n        cursor: pg.AsyncCursor,\n        author_id_1: int,\n        author_id_2: int,\n) -&gt; list[str]:\n\n    return await pg.async_get_many(\n        cursor=cursor[str],\n        select=i.title,\n        from_=i.book,\n        where=(i.author_id == author_id_1) | (i.author_id == author_id_2),\n    )\n</code></pre>"},{"location":"getting-started/read/#optional-filter","title":"Optional Filter","text":"<p>It is often convenient to define a function with multiple optional filter parameters. In such cases, you can use <code>pg.UNDEFINED</code> as the default  value. Any comparison expressions involving <code>pg.UNDEFINED</code> are automatically excluded from the where condition.</p> syncasync <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\ndef get_author(\n        cursor: pg.Cursor,\n        id_: int | pg.Undefined = pg.UNDEFINED,\n        name: str | pg.Undefined = pg.UNDEFINED,\n) -&gt; Author | None:\n\n    return pg.get_one(\n        cursor=cursor[Author],\n        select=(i.id, i.name),\n        from_=i.author,\n        where=(i.id == id_) &amp; (i.name == name), \n    )\n</code></pre> <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nasync def get_author(\n        cursor: pg.AsyncCursor,\n        id_: int | pg.Undefined = pg.UNDEFINED,\n        name: str | pg.Undefined = pg.UNDEFINED,\n) -&gt; Author | None:\n\n    return await pg.async_get_one(\n        cursor=cursor[Author],\n        select=(i.id, i.name),\n        from_=i.author,\n        where=(i.id == id_) &amp; (i.name == name), \n    )\n</code></pre>"},{"location":"getting-started/read/#group-by","title":"Group By","text":"<p>The <code>group_by</code> parameter is used to aggregate records based on one or more columns. You can provide a single  expression to group by one column or multiple expressions to group by several columns.<sup>4</sup></p> syncasync <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, functions as f\n\n\nclass AuthorStats(BaseModel):\n    author_id: int\n    n_books: int\n\n\ndef get_author_stats(cursor: pg.Cursor) -&gt; list[AuthorStats]:\n    return pg.get_many(\n        cursor=cursor[AuthorStats],\n        select=(i.author_id, f.count(i.book).AS(i.n_books)),\n        from_=i.book,\n        group_by=i.author_id,\n    )\n</code></pre> <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, functions as f\n\n\nclass AuthorStats(BaseModel):\n    author_id: int\n    n_books: int\n\n\nasync def get_author_stats(cursor: pg.AsyncCursor) -&gt; list[AuthorStats]:\n    return await pg.async_get_many(\n        cursor=cursor[AuthorStats],\n        select=(i.author_id, f.count(i.book).AS(i.n_books)),\n        from_=i.book,\n        group_by=i.author_id,\n    )\n</code></pre>"},{"location":"getting-started/read/#having","title":"Having","text":"<p>The <code>having</code> parameter is used to filter records after they have been aggregated with the <code>group_by</code> parameter. Similar to  the <code>where</code> parameter, it accepts a comparison expression as input.</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, functions as f\n\n\ndef get_top_author_ids(\n        cursor: pg.Cursor,\n        n_books: int,\n) -&gt; list[int]:\n\n    return pg.get_many(\n        cursor=cursor[int],\n        select=i.author_id,\n        from_=i.book,\n        group_by=i.author_id,\n        having=f.count(i.book) &gt; n_books,\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, functions as f\n\n\nasync def get_top_author_ids(\n        cursor: pg.AsyncCursor,\n        n_books: int,\n) -&gt; list[int]:\n\n    return await pg.async_get_many(\n        cursor=cursor[int],\n        select=i.author_id,\n        from_=i.book,\n        group_by=i.author_id,\n        having=f.count(i.book) &gt; n_books,\n    )\n</code></pre>"},{"location":"getting-started/read/#window","title":"Window","text":"<p>The <code>window</code> parameter is used to define windows, which allow calculations across a set of table rows related to the current row. You can  pass a single or sequence of expressions to the <code>window</code> parameter.</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, functions as f, QueryBuilder as q\n\ndef get_book_order(cursor: pg.Cursor) -&gt; list[tuple[int, str, int]]:\n    return pg.get_many(\n        cursor=cursor[tuple[int, str, int]],\n        select=(i.author_id, i.title, f.row_number().OVER(i.w)),\n        from_=i.book,\n        window=i.w.AS(q.PARTITION_BY(i.author_id).ORDER_BY(i.publication_date)),\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i, functions as f, QueryBuilder as q\n\n\nasync def get_book_order(cursor: pg.AsyncCursor) -&gt; list[tuple[int, str, int]]:\n    return await pg.async_get_many(\n        cursor=cursor[tuple[int, str, int]],\n        select=(i.author_id, i.title, f.row_number().OVER(i.w)),\n        from_=i.book,\n        window=i.w.AS(q.ORDER_BY(i.publication_date)),\n    )\n</code></pre>"},{"location":"getting-started/read/#order-by","title":"Order By","text":"<p>The <code>order_by</code> parameter is used to sort records based on one or more columns. It accepts either a single or a sequence of expressions.</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef get_sorted_book_ids(\n        cursor: pg.Cursor,\n        author_id: int,\n) -&gt; list[int]:\n\n    return pg.get_many(\n        cursor=cursor[int],\n        select=i.id,\n        from_=i.book,\n        where=i.author_id == author_id,\n        order_by=i.id.ASC(),\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def get_sorted_book_ids(\n        cursor: pg.AsyncCursor,\n        author_id: int,\n) -&gt; list[int]:\n\n    return await pg.async_get_many(\n        cursor=cursor[int],\n        select=i.id,\n        from_=i.book,\n        where=i.author_id == author_id,\n        order_by=i.id.ASC(),\n    )\n</code></pre>"},{"location":"getting-started/read/#optional-sort","title":"Optional Sort","text":"<p>It is often convenient to define a function with multiple optional sort parameters. In such cases, you can use <code>pg.UNDEFINED</code> as the default  value. Any sort expressions involving <code>pg.UNDEFINED</code> are automatically excluded from the <code>order_by</code>.</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import Identifier as i\n\n\ndef get_book_ids(\n        cursor: pg.Cursor,\n        author_id: int,\n        id_asc: bool | pg.Undefined = pg.UNDEFINED,\n        title_asc: bool | pg.Undefined = pg.UNDEFINED,\n) -&gt; list[int]:\n\n    return pg.get_many(\n        cursor=cursor[int],\n        select=i.id,\n        from_=i.book,\n        where=i.author_id == author_id,\n        order_by=(i.id.ASC(id_asc), i.title.ASC(title_asc)),\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def get_sorted_book_ids(\n        cursor: pg.AsyncCursor,\n        author_id: int,\n        id_asc: bool | pg.Undefined = pg.UNDEFINED,\n        title_asc: bool | pg.Undefined = pg.UNDEFINED,\n) -&gt; list[int]:\n\n    return await pg.async_get_many(\n        cursor=cursor[int],\n        select=i.id,\n        from_=i.book,\n        where=i.author_id == author_id,\n        order_by=(i.id.ASC(id_asc), i.title.ASC(title_asc)),\n    )\n</code></pre>"},{"location":"getting-started/read/#limit","title":"Limit","text":"<p>The <code>limit</code> parameter is used to restrict the number of records fetched. It is only available in the <code>get_many</code> methods  and accepts an integer as input.</p> syncasync <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\ndef get_authors(\n        cursor: pg.Cursor,\n        limit: int | None = None,\n) -&gt; list[Author]:\n\n    return pg.get_many(\n        cursor=cursor[Author],\n        select=(i.id, i.name),\n        from_=i.author,\n        limit=limit,\n    )\n</code></pre> <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nasync def get_authors(\n        cursor: pg.AsyncCursor,\n        limit: int | None = None,\n) -&gt; list[Author]:\n\n    return await pg.async_get_many(\n        cursor=cursor[Author],\n        select=(i.id, i.name),\n        from_=i.author,\n        limit=limit,\n    )\n</code></pre>"},{"location":"getting-started/read/#offset","title":"Offset","text":"<p>The <code>offset</code> parameter skips a specified number of records in the query result. It is commonly used for pagination or infinite scrolling. It accepts an integer as input.</p> syncasync <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\ndef get_authors(\n        cursor: pg.Cursor,\n        limit: int | None = None,\n        offset: int | None = None,\n) -&gt; list[Author]:\n\n    return pg.get_many(\n        cursor=cursor[Author],\n        select=(i.id, i.name),\n        from_=i.author,\n        order_by=i.id,\n        limit=limit,\n        offset=offset,\n    )\n</code></pre> <pre><code>from pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass Author(BaseModel):\n    id: int\n    name: str\n\n\nasync def get_authors(\n        cursor: pg.AsyncCursor,\n        limit: int | None = None,\n        offset: int | None = None,\n) -&gt; list[Author]:\n\n    return await pg.async_get_many(\n        cursor=cursor[Author],\n        select=(i.id, i.name),\n        from_=i.author,\n        order_by=i.id,\n        limit=limit,\n        offset=offset,\n    )\n</code></pre>"},{"location":"getting-started/read/#no-fetch","title":"No Fetch","text":"<p>The <code>no_fetch</code> parameter determines whether to fetch the data or only execute the query. It is only available in the <code>get_many</code> methods. By default, it is set to <code>False</code>. If set to <code>True</code>, the method will return a cursor, making it more time and memory efficient  when you need to iterate through the data without loading it all at once.</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef get_book_titles(cursor: pg.Cursor) -&gt; pg.Cursor[str]:\n    return pg.get_many(\n        cursor=cursor[str],\n        select=i.title,\n        from_=i.book,\n        no_fetch=True,\n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def get_book_titles(cursor: pg.AsyncCursor) -&gt; pg.AsyncCursor[str]:\n    return await pg.async_get_many(\n        cursor=cursor[str],\n        select=i.title,\n        from_=i.book,\n        no_fetch=True,\n    )\n</code></pre> <ol> <li> <p>The only reason why this parameter has a trailing underscore is that <code>from</code> is a reserved keyword.\u00a0\u21a9</p> </li> <li> <p>Only available in <code>pg.get_many</code> and <code>pg.async_get_many</code>.\u00a0\u21a9\u21a9</p> </li> <li> <p>In some cases, you may also want to include constants in your selection. To do this, simply pass the constant value directly in the select statement. Obviously you can also select constants and columns at once.\u00a0\u21a9</p> </li> <li> <p>You can also use pass integers to the <code>group_by</code> parameter to group by the respective columns in the <code>select</code>clause.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/update/","title":"Update","text":"<p> Note: Make sure to read the Getting Started, Demo Schema and Cursor first, as it is essential for better understanding of this tutorial. </p> <p>pgcrud has one function to perform synchronous update operations:</p> <ul> <li><code>pg.update_many</code>: Updates multiple records.</li> </ul> <p>And pgcrud has one function to perform asynchronous update operations:</p> <ul> <li><code>pg.async_update_many</code>: Analogous to <code>pg.update_many</code>. </li> </ul> <p>Function for single record updates do not exist because PostgreSQL UPDATE command does not inherently target a single record.</p>"},{"location":"getting-started/update/#parameters","title":"Parameters","text":"<ul> <li><code>cursor</code> (required): To execute the query. </li> <li><code>update</code> (required): To specify which table to update.</li> <li><code>set_</code> (required): To assign new values to columns.</li> <li><code>from_</code> (optional): To specify tables for subqueries.</li> <li><code>where</code> (optional): To determine which rows to update.</li> <li><code>returning</code> (optional): To fetch the updated rows.</li> <li><code>additional_values</code> (optional): Additional values that can be updated.</li> <li><code>no_fetch</code> (optional): To execute only.[^1]</li> </ul>"},{"location":"getting-started/update/#cursor","title":"Cursor","text":"<p>The <code>cursor</code> parameter is explained in detail here.</p>"},{"location":"getting-started/update/#update","title":"Update","text":"<p>The <code>update</code> parameter specifies which table to update. It expects an identifier as input.</p> syncasync <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef update_book(\n        cursor: pg.Cursor,\n        id_: int,\n        title: str,\n) -&gt; None:\n\n    pg.update_many(\n        cursor=cursor,\n        update=i.book,\n        set_=(i.title, title),\n        where=i.id == id_, \n    )\n</code></pre> <pre><code>import pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def update_book(\n        cursor: pg.AsyncCursor,\n        id_: int,\n        title: str,\n) -&gt; None:\n\n    await pg.async_update_many(\n        cursor=cursor,\n        update=i.book,\n        set_=(i.title, title),\n        where=i.id == id_, \n    )\n</code></pre>"},{"location":"getting-started/update/#set","title":"Set","text":"<p>The <code>set</code> parameter expects a tuple containing two items: the first item is either a single identifier or a sequence of identifiers  that specify the columns to be updated, while the second item can be a single value, a sequence of values, or a model instance.</p> syncasync <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorUpdate(BaseModel):\n    name: str\n    date_of_birth: date\n\n\ndef update_author(\n        cursor: pg.Cursor,\n        id_: int,\n        update: AuthorUpdate,\n) -&gt; None:\n\n        pg.update_many(\n            cursor=cursor,\n            update=i.book,\n            set_=((i.name, i.date_of_birth), update),\n            where=i.id == id_, \n        )\n</code></pre> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nclass AuthorUpdate(BaseModel):\n    name: str\n    date_of_birth: date\n\n\nasync def update_author(\n        cursor: pg.AsyncCursor,\n        id_: int,\n        update: AuthorUpdate,\n) -&gt; None:\n\n        await pg.async_update_many(\n            cursor=cursor,\n            update=i.book,\n            set_=((i.name, i.date_of_birth), update),\n            where=i.id == id_, \n        )\n</code></pre>"},{"location":"getting-started/update/#from","title":"From","text":""},{"location":"getting-started/update/#where","title":"Where","text":"<p>The <code>where</code> parameter is used to specify conditions for updating records. It  accepts a comparison expression as its input. This can be a single comparison expression or an  intersection or union of expressions. </p> syncasync <pre><code>from datetime import date\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\ndef update_book(\n        cursor: pg.Cursor,\n        author_id: int,\n        title: str,\n        publication_date: date,\n):\n\n    pg.update_many(\n        cursor=cursor,\n        update=i.book,\n        set_=(i.publication_date, publication_date),\n        where=(i.title == title) &amp; (i.author_id == author_id),\n    )\n</code></pre> <pre><code>from datetime import date\n\nimport pgcrud as pg\nfrom pgcrud import IdentifierExpression as i\n\n\nasync def update_book(\n        cursor: pg.AsyncCursor,\n        author_id: int,\n        title: str,\n        publication_date: date,\n):\n\n    await pg.async_update_many(\n        cursor=cursor,\n        update=i.book,\n        set_=(i.publication_date, publication_date),\n        where=(i.title == title) &amp; (i.author_id == author_id),\n    )\n</code></pre>"},{"location":"getting-started/update/#returning","title":"Returning","text":"<p>The <code>returning</code> parameter is used to retrieve the record after update. The <code>returning</code> parameter  expects a single or multiple expressions as input.</p>"},{"location":"getting-started/update/#additional-values","title":"Additional Values","text":""},{"location":"getting-started/update/#no-fetch","title":"No Fetch","text":""}]}